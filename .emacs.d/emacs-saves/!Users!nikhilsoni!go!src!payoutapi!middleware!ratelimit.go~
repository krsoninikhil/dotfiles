/* CASHFREE INC. PROPRIETARY AND CONFIDENTIAL
 * ------------------------------------------
 * Copyright (C) Cashfree Inc - All Rights Reserved
 * Unauthorized copying of this file, via any medium is strictly prohibited
 *
 * Description: Implements rate limiter.
 *
 * Author: Harsha <harsha@cashfree.com>, May 2019
 */

package middleware

import (
	"fmt"
	"log"
	"net/http"
	"strings"
	"time"

	"pgapi/cache"
	"pgapi/models"

	"github.com/bradfitz/gomemcache/memcache"
)

var thresholds = map[string]int{
	"_api_v1_order_create":      60,
	"_api_v1_order_update":      30,
	"_api_v1_order_info_status": 500,
	"_api_v1_captureStatus":     100,
	"_api_v1_order_capture":     100,
	"_api_v1_order_void":        100,
	"total":                     500,
}

const (
	rateLimitDefaultVal = 30
)

//RateLimiter interface declarer all the rate limiter methods
type RateLimiter interface {
	IPRLshouldBlock(r *http.Request, service string, threshold uint64) bool
	IPRLLog(r *http.Request, service string)
	OPRLshouldBlock(service string, clientID string, op string, threshold uint64, mthreshold uint64) (bool, error)
	GetThresholds(opName string, merchandID string) uint64
	GetIPKey(req *http.Request, service string) (string, string)
}

type rateLimiterImpl struct {
	rateLimits map[string]map[string]int
	cache      cache.PGAPICache
}

//InitRateLimiter initializes the rate limiter
func InitRateLimiter(rateLimitMap map[string]map[string]int, pgcache cache.PGAPICache) RateLimiter {
	return &rateLimiterImpl{
		rateLimits: rateLimitMap,
		cache:      pgcache,
	}
}

//GetThresholds maintains the rate limit thresholds
func (r *rateLimiterImpl) GetThresholds(opName string, merchandID string) uint64 {
	rateVal := rateLimitDefaultVal
	found := false
	//Search if for the given merchant specifie operation rate limit is in the rate limit config
	//we loaded at startup
	if merchantRateLimits, ok := r.rateLimits[merchandID]; ok {
		if opRateLimit, ok := merchantRateLimits[opName]; ok {
			rateVal = opRateLimit
			found = true
		}
	}
	//if it is not found in above step, we check our default configs map, if operation is not even there
	//we return a default value of rateLimitDefaultVal(30)
	if found == false {
		if opRateLimit, ok := thresholds[opName]; ok {
			rateVal = opRateLimit
		}
	}
	log.Println("merchantID :: ", merchandID, " opName :: ", opName, " rate limit :: ", rateVal)
	return uint64(rateVal)
}

//GetIPKey gets the Cache key for IP ratelimiting
func (r *rateLimiterImpl) GetIPKey(req *http.Request, service string) (string, string) {
	ip := GetClientIP(req)
	cleanIP := strings.Replace(ip, ".", "_", -1)
	t := time.Now()
	timeInMin := fmt.Sprintf("%d_%02d_%02d_%02d_%02d",
		t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute())

	key := join(service, "_", cleanIP, "_", timeInMin)
	return key, ip
}

//IPRLshouldBlock implements IP based rate limiting
func (r *rateLimiterImpl) IPRLshouldBlock(req *http.Request, service string, threshold uint64) bool {
	/* rate limiting at minute level */
	key, ip := r.GetIPKey(req, service)
	val, err := r.cache.GetNumeric(key)
	if err != nil {
		if err == memcache.ErrCacheMiss {
			log.Println("keys not present in cache::", err)
			return false
		}
		log.Println("error fetching data from cache", err)
		return false
	}

	if val >= threshold {
		//limit breached
		log.Println("API_IP_LIMIT_BREACHED Service: ", service, " IP: ", ip)
		return true
	}
	return false
}

//IPRLLog logs the requests
func (r *rateLimiterImpl) IPRLLog(req *http.Request, service string) {
	key, _ := r.GetIPKey(req, service)
	_, err := r.cache.GetNumeric(key)

	if err == nil {
		r.cache.IncrementNumeric(key, 1)
	} else if err == memcache.ErrCacheMiss {
		r.cache.SetNumeric(key, 1)
	} else {
		log.Println("IPRLLog::key not found because of::", err)
	}
	return
}

//OPRLshouldBlock implements operation rate limiting
func (r *rateLimiterImpl) OPRLshouldBlock(service string, clientID string, op string, threshold uint64, mthreshold uint64) (bool, error) {
	t := time.Now()
	timeInMin := fmt.Sprintf("%d_%02d_%02d_%02d_%02d",
		t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute())

	merchantKey := join(service, "_", clientID, "_", timeInMin)
	mval, err := r.cache.GetNumeric(merchantKey)
	if err == nil {
		if mval >= mthreshold {
			log.Println("MERCHANT_API_OP_LIMIT_BREACHED Service: ", service, " ::last call:: ", op, "::", " clientId: ", clientID)
			return true, models.ErrRateLimitMerchant
		}
		r.cache.IncrementNumeric(merchantKey, 1)
	} else if err == memcache.ErrCacheMiss {
		r.cache.SetNumeric(merchantKey, 1)
	} else {
		log.Println("OPRLshouldBlock::merchant key not found because of::", err)
	}

	key := join(service, "_", clientID, "_", op, "_", timeInMin)
	kval, err := r.cache.GetNumeric(key)
	if err == nil {
		//check and return
		if kval >= threshold {
			log.Println("MERCHANT_API_OP_LIMIT_BREACHED Service: ", service, " ::Operation:: ", op, " :: ", " clientId: ", clientID)
			return true, models.ErrRateLimitOperation
		}
		r.cache.IncrementNumeric(key, 1)
	} else if err == memcache.ErrCacheMiss {
		r.cache.SetNumeric(key, 1)
	} else {
		log.Println("OPRLshouldBlock::op key not found because of::", err)
	}
	return false, nil
}
