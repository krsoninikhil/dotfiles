package repoimplhttp

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"urlshortenersvc/logger"
	"urlshortenersvc/models"
)

// Transfer implements interface to interact with transfersvc
type Transfer struct {
	Client          *Client
	TransferSvcBase string
}

// Create calls transfer svc to create a new transfer
func (t *Transfer) Create(ctx context.Context, accID int, params *models.TransferRequest) (*models.CreateTransferDetails, error) {
	uri := fmt.Sprintf("%s/v1/accounts/%d/transfers", t.TransferSvcBase, accID)
	res, err := t.Client.PostJSON(ctx, uri, nil, params)
	if err != nil {
		logger.Error(ctx, "Create: calling internal svc", err, logger.Field("uri", uri))
		return nil, &models.InternalError{models.AppError{Msg: models.InternalErrMsg}}
	}
	defer res.Body.Close()

	switch res.StatusCode {
	case http.StatusOK, http.StatusCreated:
		data := &models.CreateTransferDetails{}
		if err := json.NewDecoder(res.Body).Decode(data); err != nil {
			logger.Error(ctx, "Create: decode success response", err, logger.Field("uri", uri), logger.Field("httpStatus", res.StatusCode))
			return nil, &models.InternalError{models.AppError{Msg: models.InternalErrMsg}}
		}
		return data, nil
	default:
		errorData := &models.Problem{}
		if err := json.NewDecoder(res.Body).Decode(errorData); err != nil {
			logger.Error(ctx, "Create: decode error response", err, logger.Field("uri", uri), logger.Field("httpStatus", res.StatusCode))
			return nil, &models.InternalError{models.AppError{Msg: models.InternalErrMsg}}
		}
		logger.Info(ctx, "Create", "error response", logger.Field("title", errorData.Type),
			logger.Field("details", errorData.Details), logger.Field("uri", uri), logger.Field("httpStatus", res.StatusCode))
		return nil, &models.TransferFailed{models.AppError{Msg: errorData.Details}}
	}
}
