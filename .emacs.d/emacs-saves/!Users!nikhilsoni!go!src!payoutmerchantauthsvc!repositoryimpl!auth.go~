/* CASHFREE INC. PROPRIETARY AND CONFIDENTIAL
 * ------------------------------------------
 * Copyright (C) Cashfree Inc - All Rights Reserved
 * Unauthorized copying of this file, via any medium is strictly prohibited
 *
 * Description: Merchant authentication repository implementation of Repository interface.
 *
 * Author: Harsha <harsha@cashfree.com>, March 2019
 */

package repositoryimpl

import (
	"context"
	"database/sql"
	"fmt"
	"net/url"

	"payoutmerchantauthsvc/config"
	"payoutmerchantauthsvc/models"
	"payoutmerchantauthsvc/repository"

	"github.com/sirupsen/logrus"
)

//TODO:: need to check if we should use any ORM e.g. GORM or Beego ORM etc?
const (
	accountChannel = "PAYOUT"
	authQuery      = `select merchantId, channel, agentId as accountId from MerchantAuthKeys
                     where clientId = ? and clientSecret = ? and isActive = ? and agent = ?`
	accountDetailsQuery = `select merchantId, channel, agentId as accountId from MerchantAuthKeys
                     where clientId = ? and isActive = ? and agent = ?`
	authIPQuery = `select merchantIP from MerchantAuthIP
                     where merchantId = ? and merchantIP = ? and channel = ? and isActive = ?`
)

type auth struct {
	Conn *sql.DB
}

// GetDbConnection returns DB connection
func GetDbConnection(cfg config.StartupConfig) (*sql.DB, error) {
	connection := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s", cfg.DbUser, cfg.DbPass, cfg.DbHost, cfg.DbPort, cfg.DbName)
	val := url.Values{}
	val.Add("charset", "utf8")
	val.Add("parseTime", "True")
	val.Add("loc", "Local")
	dsn := fmt.Sprintf("%s?%s", connection, val.Encode())
	dbConn, err := sql.Open(`mysql`, dsn)
	if err != nil {
		return nil, err
	}
	err = dbConn.Ping()
	if err != nil {
		return nil, err
	}
	return dbConn, nil
}

// ConfigureAuthRepositoryImpl will create an object that represent the article.Repository interface
func ConfigureAuthRepositoryImpl(Conn *sql.DB) repository.Repository {
	return &auth{Conn}
}

func (r *auth) fetchAccountDetails(ctx context.Context, query string, args ...interface{}) ([]*models.AccountDetails, error) {
	rows, err := r.Conn.QueryContext(ctx, query, args...)
	if err != nil {
		logrus.Error(err)
		return nil, err
	}
	defer rows.Close()
	result := make([]*models.AccountDetails, 0)
	for rows.Next() {
		t := new(models.AccountDetails)
		err = rows.Scan(&t.MerchantID, &t.AccountID, &t.Channel)
		if err != nil {
			logrus.Error(err)
			return nil, err
		}
		result = append(result, t)
	}
	return result, nil
}

func (r *auth) fetchAuthIPs(ctx context.Context, query string, args ...interface{}) ([]*models.AuthIPs, error) {
	rows, err := r.Conn.QueryContext(ctx, query, args...)
	if err != nil {
		logrus.Error(err)
		return nil, err
	}
	defer rows.Close()
	result := make([]*models.AuthIPs, 0)
	for rows.Next() {
		t := &models.AuthIPs{}
		if err = rows.Scan(&t.IPAddress); err != nil {
			logrus.Error(err)
			return nil, err
		}
		result = append(result, t)
	}
	return result, nil
}

func (r *auth) Authenticate(ctx context.Context, p *models.AuthInput) (*models.AccountDetails, error) {
	list, err := r.fetchAccountDetails(ctx, authQuery, p.ClientID, p.ClientSecret, 1, accountChannel)
	if err != nil {
		return nil, models.ErrInternalServerError
	}

	if len(list) > 0 {
		return list[0], nil
	}
	return nil, models.ErrInvalidCreds
}

func (r *auth) AccountDetails(ctx context.Context, clientID string) (*models.AccountDetails, error) {
	accounts, err := r.fetchAccountDetails(ctx, accountDetailsQuery, clientID, 1, accountChannel)
	if err != nil {
		return nil, models.ErrInternalServerError
	}

	if len(accounts) > 0 {
		return accounts[0], nil
	}
	return nil, models.ErrInvalidToken
}

func (r *auth) IsWhiteListedIP(ctx context.Context, account *models.AccountDetails, ip string) bool {
	ips, err := r.fetchAuthIPs(ctx, authIPQuery, account.MerchantID, account.Channel, ip, 1)
	if err != nil {
		logrus.Error(err)
		return false
	}

	if len(ips) > 0 {
		return true
	}
	return false
}
