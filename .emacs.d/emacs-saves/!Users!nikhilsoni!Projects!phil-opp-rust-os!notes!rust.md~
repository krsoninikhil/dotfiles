## Notes on Rust

- For a rust binary with standard library, execution is like: C
  runtime (`crt0`) -> rust runtime (`start` is entrypoint) -> program
  `main` function
- Linker options can be passed using `-C link-arg` option of `rustc`
  while compiling

  ```bash
  > cargo rustc -- -C link-arg=-nostartfiles
  ```

- Rust nightly can be used by adding `rust-toolchain` file in root
  saying `nightly`.
- While compiling Rust programs, target machine can be configured
  using pre-defined target triples or custom defined, using a json
  file specifying all the required options.
- For `no_std` crates, `core` and `compiler_builtins` libraries are
  implicitly linked which provides Rust basic types and lower lever
  functions expected by LLVM. These libs come precompiled with Rust
  compiler and are valid for pre-defined target triples.
- `cargo-xbuild` is a wrapper around `cargo` which can be used to
  compile sysroot crates (core, compiler_builtins and alloc) for
  custom targets.
- `unsafe` block of code or function can do operations which are not
  allowed by compiler like derefencing raw pointers and accessing or
  modifying mutable static variable.
- No implicity type casting in Rust. Can be done explicitly using
  `as`.
- `trait`s are almost like `interface`s in Golang or Java except
  `trait` can have default implementation. `impl` keyword is used to
  implement a `trait` `for` a `struct`. `impl` can also implement a
  `struct` without specifying a `trait`, just like Golang.
- Default implementation of some traits can be used as a implentation
  for a `struct` by using `derive` attribute. It's like interitence.
  e.g. `#[derive(Copy)]`.
- Compiler might optimize and omit the memory writes that are not
  accessed.
- Specifying memory writes as `volatile` tells compiler that value
  might change from somewhere else and should not be optimized.
- As of now, raw pointers can not be referenced in static objects.
  `lazy_static` crate can does this by computing pointer value only at
  runtime.
- `#[macro_export]` attribute brings macro to crate root and make it
  available to other modules and crates.
- Macro variable `$crate` expands in a way so macros can be directly
  used in same or external crate without breaking underlying function
  usage path.
- `cfg_attr` can be used to conditionally set the attributes.
- `Box::new()` allocates heap memory pointer and `Box::leak()` takes
  it's ref and returns mutable reference.
- Element type of array needs to derive `Copy` trait if wish to do
  initialization that copies the single value to all indices.
- Cargo features table can be used to add conditions for conditionaly
  with `cfg` attribute.
- `cargo test` builds all crates including independent binaries.
- Calling convention can be specified for a function e.g.
  `extern "C" fn`.
- `x86_64` crate provides IDT and `ExceptionStackFrame` implementation.
- To avoid null related issues, Rust have `Option<T>` enum, which can
  be `None` or `Some` with value of type `T`. Value from `Some` can be
  extracted by pattern matching.
- `if let` is short syntax for one arm pattern matching and simplify
  getting value from `Some`.
