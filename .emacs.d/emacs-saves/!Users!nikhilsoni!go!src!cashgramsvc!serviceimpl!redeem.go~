package serviceimpl

import (
	"cashgramsvc/logger"
	"cashgramsvc/models"
	"context"
	"fmt"
	"strconv"
	"time"
)

// Redeem starts the redeeming process for the Cashgram
func (r *Cashgram) Redeem(ctx context.Context, cfID int, params *models.RedeemRequest) (models.Response, error) {
	cg, err := r.CGRepo.Show(ctx, cfID)
	if _, ok := err.(*models.NotFoundError); err != nil && !ok {
		logger.Warn(ctx, "redeem: get CG details", "attempt to redeem a non existant Cashgram", logger.Field("cfID", cfID))
		return nil, &models.InternalError{models.AppError{Msg: models.InternalErrMsg}}
	} else if err != nil {
		return nil, err
	} else if cg.RetryCount >= maxRetryCount {
		logger.Warn(ctx, "redeem: retry count verification", "too many attempts", logger.Field("cfID", cfID))
		return nil, &models.TokenExpiredError{models.AppError{Msg: models.TooManyAttemptsErrMsg}}
	}

	// only verified status can proceed for redeeming
	if cg.LinkStatus != verifiedStatus {
		logger.Warn(ctx, "redeem: check status", "attempt to redeem a unverified or in process Cashgram", logger.Field("cfID", cfID))
		return nil, &models.InvalidRequestError{models.AppError{Msg: models.NotVerifiedErrMsg}}
	}
	newStatus := &models.UpdateStatusCGIntRequest{Status: inprocessStatus}
	if err = r.CGRepo.UpdateStatusByID(ctx, cfID, newStatus); err != nil {
		return nil, err
	}
	logger.Debug(ctx, "redeem", "updated Cashgram status to "+newStatus.Status)

	// add beneficiary
	// TODO: skip adding bene if tranfersvc accepts bene details directly
	now := time.Now()
	beneID := fmt.Sprintf("%s_%d", cg.CustPhone, now.Unix())
	br := &models.AddBeneRequest{
		BeneID:      beneID,
		Phone:       params.Phone,
		Name:        cg.CustName,
		Address1:    "NA",
		Email:       cg.CustEmail,
		BankAccount: params.BankAccount,
		IFSC:        params.IFSC,
		VPA:         params.VPA,
		CardNo:      params.CardNo,
	}
	if _, err := r.BeneRepo.Create(ctx, cg.AccountID, br); err != nil {
		errType, ok := err.(*models.BeneAlreadyExistError)
		if !ok {
			logger.Info(ctx, "redeem: bene add failed", err, logger.Field("cfID", cfID))
			newStatus.Status = verifiedStatus
			if err = r.CGRepo.UpdateStatusByID(ctx, cfID, newStatus); err != nil {
				logger.Error(ctx, "redeem: update status back to verified", err)
			}
			return nil, err
		}
		// if already exists, use existing beneID
		br.BeneID = errType.BeneID
	}
	logger.Debug(ctx, "redeem", "bene added")

	// start transfer
	// TODO: remove this decimal to float conversion once transfersvc supports decimal
	amount, _ := cg.Amount.Float64()
	tr := &models.TransferRequest{
		BeneID:       br.BeneID,
		Amount:       amount,
		TransferMode: params.Mode,
		TransferID:   "CG|" + cg.CashgramID + strconv.Itoa(cg.RetryCount),
		Remarks:      cg.Remarks,
	}
	finalState := &models.UpdateRefRequest{Status: pendingStatus}
	message := models.CGPendingMsg
	res, err := r.TransferRepo.Create(ctx, cg.AccountID, tr)
	if _, ok := err.(*models.TransferFailed); ok {
		if cg.RetryCount >= maxRetryCount-1 { // last allowed attemt failed
			newStatus.Status = expiredStatus
			newStatus.Reason = maxRetryCountExpiryReason
			if err = r.CGRepo.UpdateStatusByID(ctx, cfID, newStatus); err != nil {
				logger.Error(ctx, "redeem: mark expired on exceeding maximum allowed retry counts", err)
				return nil, err
			}
			return &models.RedeemResponse{Status: newStatus.Status, CashgramID: cg.CashgramID, Message: models.TooManyAttemptsErrMsg}, nil
		}
		finalState.Status = verifiedStatus // to allow retry
		message = models.CGFailedMsg
	} else if res != nil { // pending or success
		if res.Status == successStatus {
			finalState.Status = redeemedStatus
			message = models.CGRedeemedMsg
		}
		finalState.RefID = res.RefID
		finalState.UTR = res.UTR
	}

	if err = r.CGRepo.UpdateRef(ctx, cfID, finalState); err != nil {
		return nil, err
	}
	logger.Debug(ctx, "redeem", "transfersvc called")
	logger.Debug(ctx, "redeem", "updated Cashgram status to "+finalState.Status)

	if prefsData, err := r.AccountRepo.Preferences(ctx, cg.AccountID); err != nil {
		logger.Error(ctx, "redeem: fetching account prefs", err)
	} else if prefsData.NotifyUser {
		smsParams := &models.SMSParams{
			Phone:        cg.CustPhone,
			Amount:       cg.Amount,
			RefID:        finalState.RefID,
			UTR:          finalState.UTR,
			Status:       finalState.Status,
			MerchantName: prefsData.MerchantName,
		}

		if err := r.NotifRepo.SendSMS(ctx, smsParams); err != nil {
			logger.Info(ctx, "redeem: notify user", err, logger.Field("cfID", cfID))
		} else {
			logger.Debug(ctx, "redeem: notify user", "notified user")
		}
	}
	return &models.RedeemResponse{
		Status:     finalState.Status,
		RefID:      finalState.RefID,
		UTR:        finalState.UTR,
		CashgramID: cg.CashgramID,
		Message:    message,
	}, nil
}
