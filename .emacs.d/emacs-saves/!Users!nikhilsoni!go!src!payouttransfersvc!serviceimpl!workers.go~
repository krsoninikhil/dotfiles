package serviceimpl

import (
	"log"
	"payouttransfersvc/models"
	"time"
)

type transferResult struct {
	success *models.TransferBankResponse
	failure error
}

// BlockedTransfer defines the values that are required by the worker processing transfers
type BlockedTransfer struct {
	Info      *models.TransferBankRequest
	WaitingCh chan *transferResult
}

// TransferGatewayChs defines all the channels from where worker should pick up the transfers
type TransferGatewayChs struct {
	RealTime map[string](chan *BlockedTransfer)
	Bulk     map[string](chan *BlockedTransfer)
}

// InitProcessTransfers initializes the data structures required to process the transfers
func InitProcessTransfers() *TransferGatewayChs {
	gwChs := &TransferGatewayChs{
		RealTime: map[string](chan *BlockedTransfer){},
		Bulk:     map[string](chan *BlockedTransfer){},
	}

	for _, gw := range models.AvailableGateways {
		gwChs.RealTime[gw] = make(chan *BlockedTransfer)
		gwChs.Bulk[gw] = make(chan *BlockedTransfer)
	}
	return gwChs
}

// StartTransferWorkers starts workers for all the gateways
func (tsi *TransferServiceImpl) StartTransferWorkers(gwChs *TransferGatewayChs) {
	for gw, ch := range gwChs.RealTime {
		go tsi.processRealTimeTransfer(gw, ch)
	}
	for gw, ch := range gwChs.Bulk {
		go tsi.processBulkTransfer(gw, ch)
	}
	log.Println("All gateway workers started!")
}

func (tsi *TransferServiceImpl) processRealTimeTransfer(gw string, gwCh chan *BlockedTransfer) {
	tpsLimit := tsi.getTPSLimit(gw)
	for {
		time.Sleep(1 * time.Second)
		transferBatch := getTransferBatch(tpsLimit, gwCh)

		// process transfer batch
		log.Println("Transfer batch", transferBatch)

		// these routine should respond directly to WaitingCh
		for _, bt := range transferBatch {
			go tsi.callBankService(bt)
		}
	}
}

func (tsi *TransferServiceImpl) processBulkTransfer(gw string, gwCh chan *BlockedTransfer) {
	tpsLimit := tsi.getTPSLimit(gw)
	for {
		time.Sleep(1 * time.Second)
		transferBatch := getTransferBatch(tpsLimit, gwCh)

		// process transfer batch
		log.Println("Transfer batch", transferBatch)

		// these routine should respond directly to WaitingCh
		for _, bt := range transferBatch {
			go tsi.callBankService(bt)
		}
	}
}

func (tsi *TransferServiceImpl) getTPSLimit(gw string) {

}

func (tsi *TransferServiceImpl) callBankService(ti *BlockedTransfer) {
	res, err := tsi.BankInternal.MakeTransfer(ti.Info)
	ti.WaitingCh <- &transferResult{success: res, failure: err}
}

func getTransferBatch(batchSize int, gwCh chan *BlockedTransfer) []*BlockedTransfer {
	transferBatch := make([]*BlockedTransfer, 0, batchSize)
	for i := 0; i < batchSize; i++ {
		select {
		case bt := <-gwCh:
			transferBatch = append(transferBatch, bt)
		default:
			// no more requests are waiting at this moment
			return transferBatch
		}
	}
	return transferBatch
}
